module main
author unknown
version 1 0 
description ''
variables index 

script 664 414 {
whenStarted
index = 1
due_select_device 1
forever {
  comment 'driver API https://www.duelink.com/docs/products/spsnowy-a?show=driver'
  due_run (due_make_command 'setled' index 1)
  waitMillis 50
  due_run (due_make_command 'setled' index 0)
  waitMillis 50
  index += 1
  if (index == 7) {
    index = 1
  }
}
}


module 'DUELink Daisylink' Comm
author 'GHI Electronics'
version 0 13 
choices due_combx b0 b1 b2 b3 b4 b5 b6 b7 
description 'DUELink base library used by all other DUELink libraries.

Handles daisylink communications via I2C or serial (UART).
By default, this library uses serial over the Downlink port on DUELink boards and I2C on other boards but that can be changed by using the advanced "use I2C" block.

See https://www.duelink.com/docs/engine/stdlib

'
variables _dueUseI2C _dueReadTimeout 

  spec ' ' 'due_select_device' 'select device _' 'auto' 1
  spec 'r' 'due_connected' 'connected?'
  spec ' ' 'due_set_statled' 'set STAT LED to high _ ms, low _ ms, count _' 'auto auto auto' 100 100 10
  space
  space
  spec 'r' 'due_make_command' 'command _ : with _ : _ : ...' 'str auto auto' 'version'
  spec ' ' 'due_run' 'do command _' 'str' 'statled(100,100,10)'
  spec 'r' 'due_returnNum' 'do command _ returns number' 'auto' 'dread(1,2)'
  spec 'r' 'due_returnStr' 'do command _ returns string' 'str' 'version()'
  space
  space
  spec 'r' 'due_device_PID' 'device PID'
  spec 'r' 'due_device_version' 'device firmware version'
  advanced
  spec ' ' 'due_setReadTimeout' 'set response timeout _ ms' 'auto' 1000
  spec ' ' 'due_useI2C' 'use I2C _' 'bool' true
  space
  space
  spec 'r' 'due_stream_read_bytes' 'stream read from _ count _' 'menu.due_combx auto' 'b1' 3
  space
  space
  spec ' ' 'due_stop' 'stop'
  spec ' ' 'due_exec' 'run'
  space
  space
  spec ' ' '_due_init' '_due_init'
  spec ' ' '_due_send' '_due send _' 'str'
  spec ' ' '_dueSendRaw' '_due send raw _' 'auto' '10'
  spec 'r' '_due_awaitResult' '_due await result'
  spec 'r' '_due_awaitResultI2C' '_due await result (I2C)'
  spec 'r' '_due_endsWithPrompt' '_due byte array ends with prompt _' 'str'

to '_dueSendRaw' s {
  '_due_init'
  comment 'Clear receive buffer.'
  if _dueUseI2C {
    '[sensors:i2cRead]' 82 ('[data:newByteArray]' 64)
  } else {
    local 'trash' ('[serial:dueRecv]')
  }
  if _dueUseI2C {
    comment 'Assume command is < 64 bytes for now.'
    '[sensors:i2cWrite]' 82 ('[data:asByteArray]' s)
  } else {
    s = ('[data:convertType]' s 'string')
    local 'i' 1
    repeatUntil (i > (size s)) {
      local 'sent' ('[serial:dueSend]' s i)
      i += sent
      waitMillis ((sent / 10) + 1)
    }
    waitMillis 2
  }
}

to '_due_awaitResult' {
  '_due_init'
  if _dueUseI2C {
    return ('_due_awaitResultI2C')
  }
  local 'result' ('[data:makeList]')
  local 'startT' (millisOp)
  comment 'Receive data until either the next prompt character or a timeout and return the result'
  repeatUntil ((millisSince startT) > _dueReadTimeout) {
    local 'buf' ('[serial:dueRecv]')
    if ((size buf) != 0) {
      for byte buf {
        '[data:addLast]' byte result
      }
      if ('_due_endsWithPrompt' result) {
        comment 'Result ends DUE prompt sequence: 10, 13, 62'
        repeat 3 {
          '[data:delete]' 'last' result
        }
        exitLoop
      }
    }
    waitMicros 5
  }
  return ('[data:convertType]' result 'string')
}

to '_due_awaitResultI2C' {
  local 'result' (newList 20)
  '[data:delete]' 'all' result
  local 'buf' ('[data:newByteArray]' 32)
  local 'startT' (millisOp)
  repeatUntil ((millisSince startT) > _dueReadTimeout) {
    '[sensors:i2cRead]' 82 buf
    for byte buf {
      if (byte != 255) {'[data:addLast]' byte result}
    }
    if ('_due_endsWithPrompt' result) {
      comment 'Result ends DUE prompt sequence: 13, 10, 62'
      repeat 3 {
        '[data:delete]' 'last' result
      }
      exitLoop
    }
    waitMillis 1
  }
  return ('[data:convertType]' result 'string')
}

to '_due_endsWithPrompt' buffer {
  local 'end' (size buffer)
  if (end < 3) {
    return (booleanConstant false)
  }
  return (and (or ((at end buffer) == 62) ((at end buffer) == 36)) (and ((at (end - 1) buffer) == 10) ((at (end - 2) buffer) == 13)))
}

to '_due_init' {
  if (_dueReadTimeout == 0) {_dueReadTimeout = 1000}
  if (not (isType _dueUseI2C 'boolean')) {
    comment 'Not yet initialized, set _dueUseI2C.'
    if (('[misc:dueLinkPID]') > 0) {
      comment 'This is a DUELink board; use serial.'
      _dueUseI2C = (booleanConstant false)
      if ('[serial:dueSend]' ('[data:unicodeString]' 10) 1) {
        comment 'Serial need first byte is 10, 13 or ''s'', ''S'''
      }
      comment 'Wait a bit because device will see multiple commands'
      return 0
    } else {
      comment 'Not a DUELink board; use I2C.'
      _dueUseI2C = (booleanConstant true)
    }
  }
}

to '_due_send' s {
  '_due_init'
  comment 'Clear receive buffer.'
  if _dueUseI2C {
    '[sensors:i2cRead]' 82 ('[data:newByteArray]' 64)
  } else {
    local 'trash' ('[serial:dueRecv]')
  }
  if _dueUseI2C {
    comment 'Assume command is < 64 bytes for now.'
    '[sensors:i2cWrite]' 82 ('[data:join]' ('[data:asByteArray]' s) ('[data:unicodeString]' 10))
  } else {
    s = ('[data:convertType]' s 'string')
    local 'i' 1
    repeatUntil (i > (size s)) {
      local 'sent' ('[serial:dueSend]' s i)
      i += sent
      waitMillis ((sent / 10) + 1)
    }
    i += ('[serial:dueSend]' ('[data:unicodeString]' 10) 1)
    waitMillis 2
  }
}

to due_connected {
  '_due_send' ('[data:unicodeString]' 27)
  local 'n' ('[data:convertType]' (random 1 9) 'string')
  return ((due_returnStr n) == n)
}

to due_device_PID {
  local 'module PID' (due_returnNum 'info(0)')
  local 'result' ('[data:makeList]')
  for i 6 {
    local 'hexDigit' (((v 'module PID') >> (24 - (4 * i))) & 15)
    '[data:addLast]' (at (hexDigit + 1) '0123456789ABCDEF') result
  }
  return ('[data:joinStrings]' result)
}

to due_device_version {
  return (due_returnNum '100*info(1)')
}

to due_exec {
  due_run 'run'
}

to due_make_command s optionalArgs {
  local 'result' ('[data:makeList]')
  local 'str' (booleanConstant false)
  local 'arr' (booleanConstant false)
  '[data:addLast]' s result
  '[data:addLast]' '(' result
  for i 8 {
    str = (booleanConstant false)
    arr = (booleanConstant false)
    if ((argOrDefault (i + 1) '') != '') {
      comment 'check if string and "'
      if (isType (argOrDefault (i + 1) '') 'string') {
        str = (booleanConstant true)
        if (('[data:unicodeAt]' 1 (argOrDefault (i + 1) '')) == ('[data:unicodeAt]' 1 '[')) {
          comment 'Dont add "'
          arr = (booleanConstant true)
        } else {
          '[data:addLast]' '"' result
        }
      } else {
        comment 'check if array and ['
        if (isType (argOrDefault (i + 1) '') 'byte array') {
          '[data:addLast]' '[' result
        } else {
          comment 'check if list and {'
          if (isType (argOrDefault (i + 1) '') 'list') {
            '[data:addLast]' '{' result
          }
        }
      }
      if (or (isType (argOrDefault (i + 1) '') 'list') (isType (argOrDefault (i + 1) '') 'byte array')) {
        local 'arg_list' (argOrDefault (i + 1) '')
        for x (size arg_list) {
          '[data:addLast]' (at x arg_list) result
          if (x < (size arg_list)) {
            '[data:addLast]' ',' result
          }
        }
      } else {
        '[data:addLast]' (argOrDefault (i + 1) '') result
      }
      comment 'if this is a string then add "'
      if str {
        if arr {
          comment 'Dont add "'
        } else {
          '[data:addLast]' '"' result
        }
      } else {
        comment 'check if array and ['
        if (isType (argOrDefault (i + 1) '') 'byte array') {
          '[data:addLast]' ']' result
        } else {
          comment 'check if list and {'
          if (isType (argOrDefault (i + 1) '') 'list') {
            '[data:addLast]' '}' result
          }
        }
      }
    }
    if ((argOrDefault (i + 2) '') != '') {
      '[data:addLast]' ',' result
    }
  }
  '[data:addLast]' ')' result
  return ('[data:joinStrings]' result)
}

to due_returnNum cmd {
  '_due_send' cmd
  waitMillis 5
  return ('[data:convertType]' ('_due_awaitResult') 'number')
}

to due_returnStr cmd {
  '_due_send' cmd
  waitMillis 5
  return ('_due_awaitResult')
}

to due_run cmd {
  '_due_send' cmd
  local 'ignore' ('_due_awaitResult')
}

to due_select_device dev {
  due_run (due_make_command 'sel' dev)
}

to due_setReadTimeout millisecond {
  _dueReadTimeout = millisecond
}

to due_set_statled high low count {
  due_run (due_make_command 'statled' high low count)
}

to due_stop {
  comment 'Send escape to stop any running scripts'
  '_due_send' ('[data:unicodeString]' 27)
  waitMillis 100
  due_run '>'
}

to due_stream_read_bytes 'array name' count {
  local 'buf' (newList count)
  local 'buf_read' (newList 1)
  local 'found prompt' 0
  local 'idx' 0
  local 'buf2' ('[data:makeList]')
  '_due_send' ('[data:join]' 'strmrd(' (v 'array name') ',' count ')')
  repeatUntil ((v 'found prompt') == 1) {
    if _dueUseI2C {
      '[sensors:i2cRead]' 82 buf_read
      for byte buf_read {
        if (byte == 38) {'found prompt' = 1}
      }
    } else {
      local 'buf3' ('[serial:dueRecv]')
      if ((size buf3) != 0) {
        for byte buf3 {
          if ((v 'found prompt') == 1) {
            '[data:addLast]' byte buf2
            idx = (idx + 1)
          }
          if (byte == 38) {
            'found prompt' = 1
          }
        }
      }
    }
  }
  repeatUntil (idx >= count) {
    if _dueUseI2C {
      '[sensors:i2cRead]' 82 buf_read
      for byte buf_read {
        if (byte != 255) {
          idx = (idx + 1)
          atPut idx buf byte
        }
      }
    } else {
      local 'buf4' ('[serial:dueRecv]')
      if ((size buf4) != 0) {
        for byte buf4 {
          '[data:addLast]' byte buf2
          idx = (idx + 1)
        }
      }
    }
  }
  if _dueUseI2C {
    return ('[data:convertType]' buf 'byte array')
  } else {
    comment 'buf3 and buf4 may have data, we copied them to buf2 and have all response, we need buf5 to take actual data only, remove xx\r\n>'
    local 'buf5' ('[data:makeList]')
    local 'ret' 0
    for byte buf2 {
      if (ret < count) {
        '[data:addLast]' byte buf5
        ret += 1
      }
    }
    return ('[data:convertType]' buf5 'byte array')
  }
}

to due_useI2C useI2C {
  comment 'DUELink defaults to using the serial Downlink port on DUELink boards

and I2C on non-DUELink board. This advanced block is only needed

when one wants to force different behavior from the default

(e.g. to use I2C edge connector pins on a DUE CincoBit or PixoBit).'
  _dueUseI2C = useI2C
  if _dueUseI2C {
  } else {
    comment 'If Uart we need to send 10 or 13 or 27 or ''s'' or ''S'''
    due_select_device 1
  }
}


module 'DUELink Edu'
author MicroBlocks
version 1 10 
choices dueSTEM_pianoPad left right C 'C#' D 'D#' E F 'F#' G 'G#' A 'A#' B 'High C' 
choices dueSTEM_clipItPad A B left right up down 
choices dueSTEM_buttonName left right up down 
choices dueSTEM_axis x y z 
description 'Library for DUELink Educational boards: CincoBit, PixoBit, ClipIt, and DueSTEM.

The "due PID" works on all DUELink boards.
Blocks labeled "dueSTEM" work only on the DueSTEM board.

Touch sensing works only on pins with capacitive touch circuits including pins 0, 1, 2 of the CincoBit and PixoBit and all but the SCL/SDA pins of the ClipIt.
'
variables dueSTEM_accelAddr dueSTEM_touchAdjustments 

  spec 'r' 'dueSTEM_light' 'due light level (0-1000)'
  spec 'r' 'dueSTEM_LDR_button' 'due LDR button'
  spec 'r' 'dueSTEM_buzzerPin' 'due buzzer pin'
  spec 'r' 'dueSTEM_PID' 'due PID'
  space
  spec 'r' 'dueSTEM_touched' 'due pin _ touched' 'num' 1
  spec ' ' 'dueSTEM_waitForRelease' 'due wait for pin _ release' 'auto' 1
  spec 'r' 'dueSTEM_clipitPadPin' 'Clipit _ pin' 'menu.dueSTEM_clipItPad' 'A'
  spec 'r' 'dueSTEM_pianoPadPin' 'Piano _ pin' 'menu.dueSTEM_pianoPad' 'C'
  space
  spec ' ' 'dueSTEM_setLED' 'DueSTEM bulb red _ green _ blue _ (0-1000)' 'auto auto auto' 100 0 200
  spec 'r' 'dueSTEM_button' 'DueSTEM _ button' 'menu.dueSTEM_buttonName' 'left'
  spec 'r' 'dueSTEM_tilt' 'DueSTEM tilt _' 'menu.dueSTEM_axis' 'x'
  spec 'r' 'dueSTEM_temperature' 'DueSTEM temperature (x10)'
  space
  spec ' ' '_dueSTEM_accelInit' '_dueSTEM_accelInit'
  spec 'r' '_dueSTEM_accelRead16BitReg' '_dueSTEM_accelRead16BitReg _' 'auto' 13
  spec 'r' '_dueSTEM_adjustmentForPin' '_dueSTEM_adjustmentForPin _' 'num' 1
  spec 'r' '_dueSTEM_dischargeTime' '_dueSTEM_dischargeTime _' 'num' 1

to '_dueSTEM_accelInit' {
  comment 'MC3216
https://www.mouser.com/datasheet/2/821/MEMSIC_MC3216_Datasheet-1879973.pdf'
  if (dueSTEM_accelAddr != 0) {
    return
  }
  dueSTEM_accelAddr = (hexToInt '4C')
  comment 'Turn off accelerometer before changing settings'
  i2cSet dueSTEM_accelAddr 7 0
  comment 'Sampling rate: 256 Hz'
  i2cSet dueSTEM_accelAddr 8 10
  comment '+/-2G range, 10-bit resolution'
  i2cSet dueSTEM_accelAddr (hexToInt '20') 3
  comment 'Start accelerometer'
  i2cSet dueSTEM_accelAddr 7 1
}

to '_dueSTEM_accelRead16BitReg' reg {
  '_dueSTEM_accelInit'
  local 'buf' (newList 2)
  '[sensors:i2cWrite]' (hexToInt '4C') ('[data:makeList]' reg) false
  '[sensors:i2cRead]' (hexToInt '4C') buf
  local '16bit' (((at 2 buf) << 8) | (at 1 buf))
  '16bit' = (((v '16bit') << 15) >> 15)
  return ((100 * (v '16bit')) / 255)
}

to '_dueSTEM_adjustmentForPin' pin {
  if (dueSTEM_touchAdjustments == 0) {dueSTEM_touchAdjustments = (newList (digitalPins) -1)}
  local 'result' (at (pin + 1) dueSTEM_touchAdjustments)
  if (result >= 0) {
    return result
  }
  local 'total usecs' 0
  repeat 80 {
    'total usecs' += ('_dueSTEM_dischargeTime' pin)
  }
  result = (maximum 0 (minimum (((v 'total usecs') / 80) - 99) 30))
  atPut (pin + 1) dueSTEM_touchAdjustments result
  return result
}

to '_dueSTEM_dischargeTime' pin {
  comment 'Charge up pin'
  digitalWriteOp pin true
  local 'startT' (microsOp)
  waitUntil (not (digitalReadOp pin))
  local 'usecs' (microsSince startT)
  digitalWriteOp pin true
  return usecs
}

to dueSTEM_LDR_button {
  if (or ((boardType) == 'CincoBit') ((boardType) == 'PixoBit')) {return (buttonA)}
  return (digitalReadOp 20 'down')
}

to dueSTEM_PID {
  local 'result' ('[data:makeList]')
  for i 6 {
    local 'hexDigit' ((('[misc:dueLinkPID]') >> (24 - (4 * i))) & 15)
    '[data:addLast]' (at (hexDigit + 1) '0123456789ABCDEF') result
  }
  return ('[data:joinStrings]' result)
}

to dueSTEM_button which {
  if ((boardType) != 'DueSTEM') {return (booleanConstant false)}
  if ('left' == which) {
    return (digitalReadOp 20 'down')
  } ('right' == which) {
    return (digitalReadOp 1 'down')
  } ('up' == which) {
    return (digitalReadOp 18 'down')
  } ('down' == which) {
    return (digitalReadOp 10 'down')
  }
  return (booleanConstant false)
}

to dueSTEM_buzzerPin {
  if (or ((boardType) == 'CincoBit') ((boardType) == 'PixoBit')) {
    return 21
  } ((boardType) == 'DueSTEM') {
    return 3
  } ((boardType) == 'Clipit') {
    return 7
  } ((dueSTEM_PID) == '0C0001') {
    comment 'Ghizzy'
    return 3
  } ((dueSTEM_PID) == '0C0003') {
    comment 'Holiday Tree'
    return 1
  } ((dueSTEM_PID) == '0C0005') {
    comment 'Piano'
    return 3
  } ((dueSTEM_PID) == '070001') {
    comment 'Buzzer'
    return 7
  }
  return -1
}

to dueSTEM_clipitPadPin padName {
  if ('A' == padName) {
    return 10
  } ('B' == padName) {
    return 24
  } ('left' == padName) {
    return 14
  } ('right' == padName) {
    return 12
  } ('up' == padName) {
    return 13
  } ('down' == padName) {
    return 18
  } ('P1' == padName) {
    return 1
  } ('P2' == padName) {
    return 2
  } ('P3' == padName) {
    return 3
  }
  return 10
}

to dueSTEM_light {
  return (minimum ('[display:lightLevel]') 1000)
}

to dueSTEM_pianoPadPin padName {
  if ('left' == padName) {
    return 11
  } ('right' == padName) {
    return 7
  } ('C' == padName) {
    return 23
  } ('C#' == padName) {
    return 19
  } ('D' == padName) {
    return 12
  } ('D#' == padName) {
    return 13
  } ('E' == padName) {
    return 14
  } ('F' == padName) {
    return 15
  } ('F#' == padName) {
    return 16
  } ('G' == padName) {
    return 18
  } ('G#' == padName) {
    return 24
  } ('A' == padName) {
    return 10
  } ('A#' == padName) {
    return 9
  } ('B' == padName) {
    return 8
  } ('High C' == padName) {
    return 17
  }
  return 23
}

to dueSTEM_setLED r g b {
  if ((boardType) != 'DueSTEM') {return 0}
  analogWriteOp 11 r
  analogWriteOp 4 g
  analogWriteOp 2 b
}

to dueSTEM_temperature {
  if ((boardType) != 'DueSTEM') {return 0}
  local 'mVx10' ((330000 * (analogReadOp 9)) / 1023)
  return ((mVx10 - 40000) / 195)
}

to dueSTEM_tilt axis {
  if ((boardType) != 'DueSTEM') {return 0}
  if ('x' == axis) {
    return ('_dueSTEM_accelRead16BitReg' 13)
  } ('y' == axis) {
    return (0 - ('_dueSTEM_accelRead16BitReg' 15))
  } ('z' == axis) {
    return ('_dueSTEM_accelRead16BitReg' 17)
  }
  return 0
}

to dueSTEM_touched pin {
  local 'touch adjustment' ('_dueSTEM_adjustmentForPin' pin)
  comment 'Charge up pin'
  digitalWriteOp pin true
  comment 'Switch pin to input mode. Capacitor starts
discharging through 1M resistor to ground.'
  local 'ignore' (digitalReadOp pin)
  comment 'Tricky code: MicroBlocks does not switch tasks for waits of 30 usecs
or less so the following four blocks are essentially a busy wait. Because
of overhead, this takes ~140 usecs on DUELink boards. If the pin is still
high after that time, it is because it is being touched, thus increasing
the discharge time of the total effective capacitance of the pin.'
  waitMicros 30
  waitMicros 30
  waitMicros 2
  waitMicros (v 'touch adjustment')
  return (digitalReadOp pin)
}

to dueSTEM_waitForRelease pin {
  comment 'There is a lot of electrical noise while a pin is being touched.
That noise causes "due pin touched" to sometimes return false
even though the pin is still being touched. Experimentation
determined that it requires 60 to 70 "false" reports in a row to
be certain that the pin is not being touched. Those tests take
about 16 milliseconds total on an otherwise idle DUELink board.'
  local 'releaseCount' 0
  forever {
    if (dueSTEM_touched pin) {
      releaseCount = 0
    } else {
      releaseCount += 1
      if (releaseCount >= 80) {
        return 0
      }
    }
  }
}


module Tone Output
author MicroBlocks
version 1 10 
tags tone sound music audio note speaker 
choices tone_NoteName 'nt;c' 'nt;c#' 'nt;d' 'nt;d#' 'nt;e' 'nt;f' 'nt;f#' 'nt;g' 'nt;g#' 'nt;a' 'nt;a#' 'nt;b' 
description 'Audio tone generation. Make music with MicroBlocks!
'
variables _tonePin _toneInitalized _toneLoopOverhead _toneNoteNames _toneArezzoNotes _toneFrequencies 

  spec ' ' 'play tone' 'play note _ octave _ for _ ms' 'str.tone_NoteName num num' 'nt;c' 0 500
  spec ' ' 'playMIDIKey' 'play midi key _ for _ ms' 'num num' 60 500
  spec ' ' 'play frequency' 'play frequency _ for _ ms' 'num num' 261 500
  space
  spec ' ' 'startTone' 'start tone _ Hz' 'num' 440
  spec ' ' 'stopTone' 'stop tone'
  space
  spec ' ' 'attach buzzer to pin' 'attach buzzer to pin _' 'auto' ''
  space
  spec 'r' '_measureLoopOverhead' '_measureLoopOverhead'
  spec 'r' '_baseFreqForNote' '_baseFreqForNote _' 'auto' 'c'
  spec 'r' '_baseFreqForSemitone' '_baseFreqForSemitone _' 'num' 0
  spec ' ' '_toneLoop' '_toneLoop _ for _ ms' 'num num' 440000 100
  spec 'r' '_trimmedLowercase' '_trimmedLowercase _' 'str' 'A. b C...'
  spec ' ' '_tone init note names' '_tone init note names'

to '_baseFreqForNote' note {
  comment 'Return the frequency for the given note in the middle-C octave
scaled by 1000. For example, return 440000 (440Hz) for A.
Note names may be upper or lower case. Note names
may be followed by # for a sharp or b for a flat.'
  local 'normalized note' ('_trimmedLowercase' note)
  'normalized note' = (ifExpression ((at 1 (v 'normalized note')) == 'n') (v 'normalized note') ('[data:join]' 'nt;' (v 'normalized note')))
  '_tone init note names'
  if (('[data:find]' (v 'normalized note') _toneArezzoNotes) > 0) {
    return ('_baseFreqForSemitone' ('[data:find]' (v 'normalized note') _toneArezzoNotes))
  } else {
    return ('_baseFreqForSemitone' ('[data:find]' (v 'normalized note') _toneNoteNames))
  }
}

to '_baseFreqForSemitone' semitone {
  if (_toneFrequencies == 0) {_toneFrequencies = ('[data:makeList]' 261626 277183 293665 311127 329628 349228 369994 391995 415305 440000 466164 493883 246942 277183 277183 311127 311127 349228 329628 369994 369994 415305 415305 466164 466164 523252)}
  if (and (1 <= semitone) (semitone <= (size _toneFrequencies))) {
    return (at semitone _toneFrequencies)
  } else {
    comment 'Bad note name; return 10 Hz'
    return 10000
  }
}

to '_measureLoopOverhead' {
  comment 'Measure the loop overhead on this device'
  local 'halfCycle' 100
  local 'startT' (microsOp)
  repeat 100 {
    digitalWriteOp _tonePin false
    waitMicros halfCycle
    digitalWriteOp _tonePin false
    waitMicros halfCycle
  }
  local 'usecs' ((microsOp) - startT)
  return ((usecs - 20000) / 200)
}

to '_tone init note names' {
  if (_toneNoteNames == 0) {
    _toneNoteNames = ('[data:makeList]' 'nt;c' 'nt;c#' 'nt;d' 'nt;d#' 'nt;e' 'nt;f' 'nt;f#' 'nt;g' 'nt;g#' 'nt;a' 'nt;a#' 'nt;b' 'nt;c_' 'nt;db' 'nt;d_' 'nt;eb' 'nt;e_' 'nt;e#' 'nt;f_' 'nt;gb' 'nt;g_' 'nt;ab' 'nt;a_' 'nt;bb' 'nt;b_' 'nt;b#')
    _toneArezzoNotes = ('[data:makeList]' 'nt;do' 'nt;do#' 'nt;re' 'nt;re#' 'nt;mi' 'nt;fa' 'nt;fa#' 'nt;sol' 'nt;sol#' 'nt;la' 'nt;la#' 'nt;si' 'nt;do_' 'nt;dob' 'nt;re_' 'nt;reb' 'nt;mi_' 'nt;mi#' 'nt;fa_' 'nt;solb' 'nt;sol_' 'nt;lab' 'nt;la_' 'nt;sib' 'nt;si_' 'nt;si#')
  }
}

to '_toneLoop' scaledFreq ms {
  if (_toneInitalized == 0) {'attach buzzer to pin' ''}
  if ('[io:hasTone]') {
    '[io:playTone]' _tonePin (scaledFreq / 1000)
    waitMillis ms
    '[io:playTone]' _tonePin 0
  } else {
    local 'halfCycle' ((500000000 / scaledFreq) - _toneLoopOverhead)
    local 'cycles' ((ms * 500) / halfCycle)
    repeat cycles {
      digitalWriteOp _tonePin true
      waitMicros halfCycle
      digitalWriteOp _tonePin false
      waitMicros halfCycle
    }
  }
}

to '_trimmedLowercase' s {
  comment 'Return a copy of the given string without whitespace
or periods and all lowercase.'
  local 'result' (newList (size s))
  '[data:delete]' 'all' result
  for i (size s) {
    local 'ch' ('[data:unicodeAt]' i s)
    if (and (ch > 32) (ch != 46)) {
      if (and (65 <= ch) (ch <= 90)) {ch = (ch + 32)}
      '[data:addLast]' ch result
    }
  }
  return ('[data:unicodeString]' result)
}

to 'attach buzzer to pin' pinNumber {
  if (pinNumber == '') {
    comment 'Pin number not specified; use default pin for this device'
    if ((boardType) == 'Citilab ED1') {
      _tonePin = 26
    } ((boardType) == 'M5Stack-Core') {
      _tonePin = 25
    } ((boardType) == 'M5StickC') {
      _tonePin = 26
    } ((boardType) == 'Calliope') {
      digitalWriteOp 23 true
      digitalWriteOp 24 true
      _tonePin = 25
    } ((boardType) == 'D1-Mini') {
      _tonePin = 12
    } ((boardType) == 'CodingBox') {
      _tonePin = 32
    } else {
      _tonePin = -1
    }
  } else {
    _tonePin = pinNumber
  }
  _toneLoopOverhead = ('_measureLoopOverhead')
  _toneInitalized = (booleanConstant true)
}

to 'play frequency' freq ms {
  '_toneLoop' (freq * 1000) ms
}

to 'play tone' note octave ms {
  local 'freq' ('_baseFreqForNote' note)
  if (freq <= 10000) {
    waitMillis ms
    return 0
  }
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  '_toneLoop' freq ms
}

to playMIDIKey key ms {
  local 'freq' ('_baseFreqForSemitone' ((key % 12) + 1))
  local 'octave' ((key / 12) - 5)
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  '_toneLoop' freq ms
}

to startTone freq {
  if (_toneInitalized == 0) {'attach buzzer to pin' ''}
  if ('[io:hasTone]') {'[io:playTone]' _tonePin freq}
}

to stopTone {
  startTone 0
}

